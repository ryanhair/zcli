const std = @import("std");

/// Base command executor that plugins can transform
/// This is the foundation of the command pipeline system
pub const BaseCommandExecutor = struct {
    /// Execute a command with the given context and arguments
    /// This is the core execution function that plugins can wrap
    pub fn execute(ctx: anytype, args: anytype) !void {
        // Get the command type from args
        const CommandType = @TypeOf(args);
        
        // Look for an execute function on the command
        if (@hasDecl(CommandType, "execute")) {
            // Call the command's execute function
            try CommandType.execute(ctx, args);
        } else {
            // If no execute function, this is an error
            try ctx.io.stderr.print("Error: Command does not implement execute function\n", .{});
            return error.CommandNotImplemented;
        }
    }
};

/// Base error handler that plugins can transform
/// This handles errors that occur during command execution
pub const BaseErrorHandler = struct {
    /// Handle an error with the given context
    pub fn handle(err: anyerror, ctx: anytype) !void {
        // Default error handling - just print the error
        const error_name = @errorName(err);
        
        // Try to provide helpful error messages for common errors
        switch (err) {
            error.CommandNotFound => {
                try ctx.io.stderr.print("Error: Command not found\n", .{});
                if (@hasField(@TypeOf(ctx), "attempted_command")) {
                    try ctx.io.stderr.print("Unknown command: '{s}'\n", .{ctx.attempted_command});
                }
            },
            error.InvalidArgument => {
                try ctx.io.stderr.print("Error: Invalid argument provided\n", .{});
            },
            error.MissingArgument => {
                try ctx.io.stderr.print("Error: Required argument missing\n", .{});
            },
            error.InvalidOption => {
                try ctx.io.stderr.print("Error: Invalid option provided\n", .{});
            },
            error.PermissionDenied => {
                try ctx.io.stderr.print("Error: Permission denied\n", .{});
            },
            error.FileNotFound => {
                try ctx.io.stderr.print("Error: File not found\n", .{});
            },
            error.OutOfMemory => {
                try ctx.io.stderr.print("Error: Out of memory\n", .{});
            },
            else => {
                // Generic error message for unknown errors
                try ctx.io.stderr.print("Error: {s}\n", .{error_name});
            },
        }
        
        // Return the error so it can be propagated if needed
        return err;
    }
};

/// Base help generator that plugins can transform
/// This generates help text for commands and the application
pub const BaseHelpGenerator = struct {
    /// Generate help text for a command or the entire application
    pub fn generate(ctx: anytype, command_name: ?[]const u8) ![]const u8 {
        var buffer = std.ArrayList(u8).init(ctx.allocator);
        const writer = buffer.writer();
        
        if (command_name) |cmd_name| {
            // Generate help for a specific command
            try writer.print("Help for command: {s}\n\n", .{cmd_name});
            
            // Basic command help (detailed lookup would be provided by the generated registry)
            try writer.print("Usage: {s} {s} [arguments] [options]\n\n", .{ ctx.app_name, cmd_name });
            try writer.print("Command '{s}' help would be generated by the actual command implementation.\n", .{cmd_name});
            try writer.writeAll("Use the generated registry for detailed command introspection.\n");
        } else {
            // Generate general application help
            try writer.print("{s} - {s}\n", .{ ctx.app_name, ctx.app_description });
            try writer.print("Version: {s}\n\n", .{ctx.app_version});
            
            try writer.print("Usage: {s} <command> [arguments] [options]\n\n", .{ctx.app_name});
            
            try writer.writeAll("Available commands:\n");
            
            // List all available commands - this will be empty in the base generator
            // The actual command list should be provided by the generated registry's help pipeline
            // For now, we show a placeholder that the help pipeline should override
            try writer.writeAll("  (Command list will be populated by generated help pipeline)\n");
            
            try writer.print("\nUse '{s} <command> --help' for more information about a command.\n", .{ctx.app_name});
        }
        
        return buffer.toOwnedSlice();
    }
};

// Helper types for tests (these are properly defined in zcli.zig)
const TestIO = struct {
    stdout: std.io.AnyWriter,
    stderr: std.io.AnyWriter,
    stdin: std.io.AnyReader,
    
    pub fn init() TestIO {
        return .{
            .stdout = std.io.getStdOut().writer().any(),
            .stderr = std.io.getStdErr().writer().any(),
            .stdin = std.io.getStdIn().reader().any(),
        };
    }
};

// Tests
test "BaseCommandExecutor executes commands" {
    const TestCommand = struct {
        pub fn execute(ctx: anytype, args: anytype) !void {
            _ = ctx;
            _ = args;
            // Test command execution
        }
    };
    
    const test_ctx = struct {
        io: TestIO = TestIO.init(),
    }{};
    
    const test_args = TestCommand{};
    
    try BaseCommandExecutor.execute(test_ctx, test_args);
}

test "BaseErrorHandler handles common errors" {
    const test_ctx = struct {
        io: TestIO = TestIO.init(),
        attempted_command: []const u8 = "test",
    }{};
    
    // Test handling CommandNotFound
    _ = BaseErrorHandler.handle(error.CommandNotFound, test_ctx) catch {};
    
    // Test handling InvalidArgument
    _ = BaseErrorHandler.handle(error.InvalidArgument, test_ctx) catch {};
}

test "BaseHelpGenerator generates help text" {
    const allocator = std.testing.allocator;
    
    const test_ctx = struct {
        allocator: std.mem.Allocator,
        io: TestIO = TestIO.init(),
        app_name: []const u8 = "testapp",
        app_version: []const u8 = "1.0.0",
        app_description: []const u8 = "Test application",
    }{
        .allocator = allocator,
    };
    
    // Generate general help
    const help = try BaseHelpGenerator.generate(test_ctx, null);
    defer allocator.free(help);
    
    try std.testing.expect(std.mem.indexOf(u8, help, "testapp") != null);
    try std.testing.expect(std.mem.indexOf(u8, help, "1.0.0") != null);
}