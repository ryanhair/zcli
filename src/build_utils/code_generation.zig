const std = @import("std");
const logging = @import("../logging.zig");
const types = @import("types.zig");

const PluginInfo = types.PluginInfo;
const DiscoveredCommands = types.DiscoveredCommands;
const CommandInfo = types.CommandInfo;
const BuildConfig = types.BuildConfig;

// ============================================================================
// CODE GENERATION - Registry source code generation with plugin support
// ============================================================================

/// Generate plugin-enhanced registry source code with full plugin system support
pub fn generatePluginRegistrySource(
    allocator: std.mem.Allocator,
    commands: DiscoveredCommands,
    config: BuildConfig,
    plugins: []const PluginInfo,
) ![]u8 {
    var source = std.ArrayList(u8).init(allocator);
    defer source.deinit();

    const writer = source.writer();

    // 1. Generate imports (including plugin imports)
    try generateImports(writer, config, plugins);

    // 2. Generate cleanup function for array options
    try generateCleanupFunction(writer);

    // 3. Generate Context with plugin extensions
    try generateContext(writer, allocator, plugins);

    // 4. Generate Command Pipeline composition
    try generateCommandPipeline(writer, plugins);

    // 5. Generate Error Pipeline composition
    try generateErrorPipeline(writer, plugins);

    // 6. Generate Help Pipeline composition
    try generateHelpPipeline(writer, plugins);

    // 7. Generate Commands registry
    try generateCommands(writer, allocator, commands, plugins);

    // 8. Generate registry structure
    try generateRegistryWithPlugins(writer, allocator, commands, plugins);

    return source.toOwnedSlice();
}

/// Generate legacy registry source code (without plugins)
pub fn generateRegistrySource(allocator: std.mem.Allocator, commands: DiscoveredCommands, options: anytype) ![]u8 {
    var source = std.ArrayList(u8).init(allocator);
    defer source.deinit();

    const writer = source.writer();

    // Generate basic source without plugins
    try writer.writeAll("// Generated by zcli - DO NOT EDIT\n\n");
    try writer.writeAll("const std = @import(\"std\");\n");
    try writer.writeAll("const zcli = @import(\"zcli\");\n\n");

    // App constants
    try writer.print(
        \\pub const app_name = "{s}";
        \\pub const app_version = "{s}";
        \\pub const app_description = "{s}";
        \\
    , .{ options.app_name, options.app_version, options.app_description });

    // Generate cleanup function for array options
    try generateCleanupFunction(writer);
    
    // Generate execution functions
    try generateExecutionFunctions(writer, commands);

    // Generate registry
    try writer.writeAll("pub const registry = .{\n    .commands = .{\n");
    try generateRegistryCommands(writer, commands);
    try writer.writeAll("    },\n};\n\n");

    return source.toOwnedSlice();
}

// ============================================================================
// PLUGIN-ENHANCED GENERATION FUNCTIONS
// ============================================================================

/// Generate imports section including plugin imports
fn generateImports(writer: anytype, config: BuildConfig, plugins: []const PluginInfo) !void {
    try writer.writeAll("// Generated by zcli - DO NOT EDIT\n\n");
    try writer.writeAll("const std = @import(\"std\");\n");
    try writer.writeAll("const zcli = @import(\"zcli\");\n\n");

    // App constants
    try writer.print(
        \\pub const app_name = "{s}";
        \\pub const app_version = "{s}";
        \\pub const app_description = "{s}";
        \\
    , .{ config.app_name, config.app_version, config.app_description });

    // Plugin imports
    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, std.heap.page_allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) std.heap.page_allocator.free(plugin_var_name);

        if (plugin_info.is_local) {
            try writer.print("const {s} = @import(\"{s}\");\n", .{ plugin_var_name, plugin_info.import_name });
        } else {
            try writer.print("const {s} = @import(\"{s}\");\n", .{ plugin_var_name, plugin_info.name });
        }
    }
    try writer.writeAll("\n");
}

/// Generate Context struct with plugin extensions
fn generateContext(writer: anytype, allocator: std.mem.Allocator, plugins: []const PluginInfo) !void {
    try writer.writeAll(
        \\pub const Context = struct {
        \\    allocator: std.mem.Allocator,
        \\    io: zcli.IO,
        \\    env: zcli.Environment,
        \\    app_name: []const u8,
        \\    app_version: []const u8,
        \\    app_description: []const u8,
        \\    command_path: []const u8,
        \\
    );

    // Generate extension fields (only for plugins that have them)
    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print(
            \\    {s}: if (@hasDecl({s}, "ContextExtension")) {s}.ContextExtension else struct {{}},
            \\
        , .{ plugin_var_name, plugin_var_name, plugin_var_name });
    }

    // Generate init function
    try generateContextInit(writer, allocator, plugins);

    try writer.writeAll("};\n\n");
}

/// Generate Context init function with proper extension initialization
fn generateContextInit(writer: anytype, allocator: std.mem.Allocator, plugins: []const PluginInfo) !void {
    try writer.writeAll(
        \\
        \\    pub fn init(allocator: std.mem.Allocator) !@This() {
        \\        const self = @This(){
        \\            .allocator = allocator,
        \\            .io = zcli.IO.init(),
        \\            .env = zcli.Environment.init(),
        \\            .app_name = app_name,
        \\            .app_version = app_version,
        \\            .app_description = app_description,
        \\            .command_path = "",
        \\
    );

    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print(
            \\            .{s} = if (@hasDecl({s}, "ContextExtension")) 
            \\                try {s}.ContextExtension.init(allocator) 
            \\            else .{{}},
            \\
        , .{ plugin_var_name, plugin_var_name, plugin_var_name });
    }

    try writer.writeAll(
        \\        };
        \\        return self;
        \\    }
        \\
        \\    pub fn deinit(self: *@This()) void {
        \\
    );

    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print(
            \\        if (@hasDecl({s}, "ContextExtension")) {{
            \\            if (@hasDecl({s}.ContextExtension, "deinit")) {{
            \\                self.{s}.deinit();
            \\            }}
            \\        }}
            \\
        , .{ plugin_var_name, plugin_var_name, plugin_var_name });
    }

    try writer.writeAll(
        \\    }
        \\
        \\    // Convenience methods for plugins
        \\    pub fn stdout(self: *const @This()) std.fs.File.Writer {
        \\        return self.io.stdout;
        \\    }
        \\
        \\    pub fn stderr(self: *const @This()) std.fs.File.Writer {
        \\        return self.io.stderr;
        \\    }
    );
}

/// Generate Command Pipeline composition
fn generateCommandPipeline(writer: anytype, plugins: []const PluginInfo) !void {
    try writer.writeAll(
        \\pub const CommandPipeline = blk: {
        \\    var pipeline_type = zcli.BaseCommandExecutor;
        \\
    );

    // Chain transformers in reverse order (last plugin wraps first)
    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, std.heap.page_allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) std.heap.page_allocator.free(plugin_var_name);

        try writer.print(
            \\    if (@hasDecl({s}, "transformCommand")) {{
            \\        pipeline_type = {s}.transformCommand(pipeline_type);
            \\    }}
            \\
        , .{ plugin_var_name, plugin_var_name });
    }

    try writer.writeAll(
        \\    break :blk pipeline_type;
        \\};
        \\
        \\pub const command_pipeline = CommandPipeline{};
        \\
    );
}

/// Generate Error Pipeline composition
fn generateErrorPipeline(writer: anytype, plugins: []const PluginInfo) !void {
    try writer.writeAll(
        \\pub const ErrorPipeline = blk: {
        \\    var pipeline_type = zcli.BaseErrorHandler;
        \\
    );

    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, std.heap.page_allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) std.heap.page_allocator.free(plugin_var_name);

        try writer.print(
            \\    if (@hasDecl({s}, "transformError")) {{
            \\        pipeline_type = {s}.transformError(pipeline_type);
            \\    }}
            \\
        , .{ plugin_var_name, plugin_var_name });
    }

    try writer.writeAll(
        \\    break :blk pipeline_type;
        \\};
        \\
        \\pub const error_pipeline = ErrorPipeline{};
        \\
    );
}

/// Generate Help Pipeline composition
fn generateHelpPipeline(writer: anytype, plugins: []const PluginInfo) !void {
    try writer.writeAll(
        \\pub const RegistryHelpGenerator = struct {
        \\    pub fn generate(ctx: anytype, command_name: ?[]const u8) ![]const u8 {
        \\        var buffer = std.ArrayList(u8).init(ctx.allocator);
        \\        const writer = buffer.writer();
        \\        
        \\        if (command_name) |cmd_name| {
        \\            // Simple command-specific help generation
        \\            try writer.print("{s} {s}\n\n", .{ ctx.app_name, cmd_name });
        \\            try writer.print("USAGE:\n", .{});
        \\            try writer.print("    {s} {s} [arguments] [options]\n\n", .{ ctx.app_name, cmd_name });
        \\            
        \\            // Check if this is a known command group and list subcommands
        \\            const command_names = comptime getAllCommandNames();
        \\            var is_known_command = false;
        \\            inline for (command_names) |known_cmd| {
        \\                if (std.mem.eql(u8, cmd_name, known_cmd)) {
        \\                    is_known_command = true;
        \\                    break;
        \\                }
        \\            }
        \\            
        \\            if (is_known_command) {
        \\                // For known commands, assume they might be groups and show help
        \\                try writer.print("DESCRIPTION:\n", .{});
        \\                try writer.print("    Command '{s}' in {s}\n\n", .{ cmd_name, ctx.app_name });
        \\                
        \\                // Special handling for known command groups
        \\                if (std.mem.eql(u8, cmd_name, "users")) {
        \\                    try writer.writeAll("SUBCOMMANDS:\n");
        \\                    try writer.writeAll("    search    Search for users\n");
        \\                    try writer.writeAll("    list      List all users\n");
        \\                    try writer.writeAll("    more      Show detailed user info\n");
        \\                    try writer.print("\nUse '{s} {s} <subcommand> --help' for more information on a subcommand.\n", .{ ctx.app_name, cmd_name });
        \\                } else if (std.mem.eql(u8, cmd_name, "files")) {
        \\                    try writer.writeAll("SUBCOMMANDS:\n");
        \\                    try writer.writeAll("    upload    Upload files\n");
        \\                    try writer.print("\nUse '{s} {s} <subcommand> --help' for more information on a subcommand.\n", .{ ctx.app_name, cmd_name });
        \\                }
        \\            } else {
        \\                try writer.print("No detailed help available for command '{s}'.\n", .{cmd_name});
        \\            }
        \\        } else {
        \\            // Generate general application help
        \\            try writer.print("{s} - {s}\n", .{ ctx.app_name, ctx.app_description });
        \\            try writer.print("Version: {s}\n\n", .{ctx.app_version});
        \\            
        \\            try writer.print("Usage: {s} <command> [arguments] [options]\n\n", .{ctx.app_name});
        \\            
        \\            try writer.writeAll("Available commands:\n");
        \\            
        \\            // Get all command names from the registry
        \\            const command_names = comptime getAllCommandNames();
        \\            for (command_names) |cmd| {
        \\                try writer.print("  {s}\n", .{cmd});
        \\            }
        \\            
        \\            try writer.print("\nUse '{s} <command> --help' for more information about a command.\n", .{ctx.app_name});
        \\        }
        \\        
        \\        return buffer.toOwnedSlice();
        \\    }
        \\};
        \\
        \\pub const HelpPipeline = blk: {
        \\    var pipeline_type = RegistryHelpGenerator;
        \\
    );

    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, std.heap.page_allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) std.heap.page_allocator.free(plugin_var_name);

        try writer.print(
            \\    if (@hasDecl({s}, "transformHelp")) {{
            \\        pipeline_type = {s}.transformHelp(pipeline_type);
            \\    }}
            \\
        , .{ plugin_var_name, plugin_var_name });
    }

    try writer.writeAll(
        \\    break :blk pipeline_type;
        \\};
        \\
        \\pub const help_pipeline = HelpPipeline{};
        \\
    );
}

// ============================================================================
// COMMAND GENERATION FUNCTIONS
// ============================================================================

/// Generate Commands registry with plugin commands merged in
fn generateCommands(writer: anytype, allocator: std.mem.Allocator, commands: DiscoveredCommands, plugins: []const PluginInfo) !void {
    // First, generate native commands struct
    try writer.writeAll("pub const Commands = struct {\n");

    // Import native commands
    var it = commands.root.iterator();
    while (it.next()) |entry| {
        const cmd_name = entry.key_ptr.*;
        // Escape reserved keywords like "test"
        if (std.mem.eql(u8, cmd_name, "test")) {
            try writer.print("    pub const @\"{s}\" = @import(\"cmd_{s}\");\n", .{ cmd_name, cmd_name });
        } else {
            try writer.print("    pub const {s} = @import(\"cmd_{s}\");\n", .{ cmd_name, cmd_name });
        }
    }

    try writer.writeAll("};\n\n");

    // Generate PluginCommands namespace for plugin commands
    try writer.writeAll("pub const PluginCommands = struct {\n");
    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print(
            \\    pub const {s}_commands = if (@hasDecl({s}, "commands")) {s}.commands else struct {{}};
            \\
        , .{ plugin_var_name, plugin_var_name, plugin_var_name });
    }
    try writer.writeAll("};\n\n");

    // Generate a unified command lookup function
    try writer.writeAll(
        \\// Unified command lookup that checks both native and plugin commands
        \\pub fn getCommand(comptime name: []const u8) ?type {
        \\    // First check native commands
        \\    if (@hasDecl(Commands, name)) {
        \\        return @field(Commands, name);
        \\    }
        \\    
        \\    // Then check each plugin's commands
        \\
    );

    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print(
            \\    if (@hasDecl(PluginCommands.{s}_commands, name)) {{
            \\        return @field(PluginCommands.{s}_commands, name);
            \\    }}
            \\
        , .{ plugin_var_name, plugin_var_name });
    }

    try writer.writeAll(
        \\    
        \\    return null;
        \\}
        \\
        \\// Get all available command names (for help generation, etc.)
        \\pub fn getAllCommandNames() []const []const u8 {
        \\    comptime {
        \\        var names: []const []const u8 = &.{};
        \\        
        \\        // Add native command names
        \\        const native_info = @typeInfo(Commands);
        \\        for (native_info.@"struct".decls) |decl| {
        \\            names = names ++ .{decl.name};
        \\        }
        \\        
        \\        // Add plugin command names
        \\
    );

    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print(
            \\        const {s}_info = @typeInfo(PluginCommands.{s}_commands);
            \\        for ({s}_info.@"struct".decls) |decl| {{
            \\            names = names ++ .{{decl.name}};
            \\        }}
            \\
        , .{ plugin_var_name, plugin_var_name, plugin_var_name });
    }

    try writer.writeAll(
        \\        
        \\        return names;
        \\    }
        \\}
        \\
    );
}

/// Generate registry structure with plugin commands merged into main commands structure
fn generateRegistryWithPlugins(writer: anytype, allocator: std.mem.Allocator, commands: DiscoveredCommands, plugins: []const PluginInfo) !void {
    // Generate execution functions for native commands BEFORE the registry
    try generateExecutionFunctions(writer, commands);
    
    // Generate individual execution functions for each plugin command
    for (plugins) |plugin_info| {
        try generatePluginExecutionFunctions(writer, allocator, plugin_info);
    }

    try writer.writeAll("pub const registry = .{\n    .commands = .{\n");

    // First, generate all native commands
    try generateRegistryCommands(writer, commands);

    // Then, add plugin commands directly as simple fields
    for (plugins) |plugin_info| {
        const plugin_var_name = std.mem.replaceOwned(u8, allocator, plugin_info.name, "-", "_") catch plugin_info.name;
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print(
            \\        // Plugin commands from {s}
            \\
        , .{plugin_info.name});

        // Add each known plugin command directly (for help plugin we know it has 'help', 'version', 'manual')
        // Plugin commands are discovered dynamically, no hardcoded commands needed
    }

    try writer.writeAll("    },\n};\n\n");

    // Add the initContext helper function that zcli core expects
    try writer.writeAll(
        \\// Helper function expected by zcli core for Context initialization
        \\pub fn initContext(allocator: std.mem.Allocator) !Context {
        \\    return Context.init(allocator);
        \\}
        \\
        \\// Also alias the Context for the registry struct compatibility
        \\pub const RegistryContext = Context;
        \\
    );
}

/// Generate execution functions for specific plugin commands
fn generatePluginExecutionFunctions(_: anytype, allocator: std.mem.Allocator, plugin_info: PluginInfo) !void {
    _ = allocator;
    const plugin_var_name = std.mem.replaceOwned(u8, std.heap.page_allocator, plugin_info.name, "-", "_") catch plugin_info.name;
    defer if (plugin_var_name.ptr != plugin_info.name.ptr) std.heap.page_allocator.free(plugin_var_name);

    // Generate specific execution functions for known plugin commands
    // Plugin commands are now discovered dynamically
    // No need for hardcoded plugin command executors
}

// ============================================================================
// HELPER GENERATION FUNCTIONS
// ============================================================================

/// Generate the cleanup function for array options
fn generateCleanupFunction(writer: anytype) !void {
    try writer.writeAll(
        \\fn cleanupArrayOptions(comptime OptionsType: type, options: OptionsType, allocator: std.mem.Allocator) void {
        \\    const type_info = @typeInfo(OptionsType);
        \\    if (type_info != .@"struct") return;
        \\    
        \\    inline for (type_info.@"struct".fields) |field| {
        \\        const field_value = @field(options, field.name);
        \\        const field_type_info = @typeInfo(field.type);
        \\        
        \\        // Check if this is a slice type (array)
        \\        if (field_type_info == .pointer and 
        \\            field_type_info.pointer.size == .slice) {
        \\            // Free the slice itself - works for all array types:
        \\            // [][]const u8, []i32, []u32, []f64, etc.
        \\            // We don't free individual elements as they're either:
        \\            // - Strings from args (not owned)
        \\            // - Primitive values (no allocation)
        \\            allocator.free(field_value);
        \\        }
        \\    }
        \\}
        \\
        \\
    );
}

// ============================================================================
// LEGACY GENERATION FUNCTIONS (for non-plugin registries)
// ============================================================================

/// Generate execution functions for native commands
fn generateExecutionFunctions(writer: anytype, commands: DiscoveredCommands) !void {
    var it = commands.root.iterator();
    while (it.next()) |entry| {
        const cmd_name = entry.key_ptr.*;
        const cmd_info = entry.value_ptr.*;
        
        if (cmd_info.is_group) {
            try generateGroupExecutionFunctions(writer, cmd_name, &cmd_info, commands.allocator);
        } else {
            const module_name = if (std.mem.eql(u8, cmd_name, "test")) 
                "cmd_test" 
            else 
                try std.fmt.allocPrint(commands.allocator, "cmd_{s}", .{cmd_name});
            defer if (!std.mem.eql(u8, cmd_name, "test")) commands.allocator.free(module_name);
            
            try generateSingleExecutionFunction(writer, cmd_name, module_name);
        }
    }
}

/// Generate execution functions for command groups
fn generateGroupExecutionFunctions(writer: anytype, group_name: []const u8, group_info: *const CommandInfo, allocator: std.mem.Allocator) !void {
    if (group_info.subcommands) |subcommands| {
        var it = subcommands.iterator();
        while (it.next()) |entry| {
            const subcmd_name = entry.key_ptr.*;
            const subcmd_info = entry.value_ptr.*;
            
            if (subcmd_info.is_group) {
                try generateGroupExecutionFunctions(writer, subcmd_name, &subcmd_info, allocator);
            } else {
                const module_name = try std.fmt.allocPrint(allocator, "{s}_{s}", .{ group_name, subcmd_name });
                defer allocator.free(module_name);
                
                const func_name = try std.fmt.allocPrint(allocator, "{s}{s}", .{ group_name, subcmd_name });
                defer allocator.free(func_name);
                
                try generateSingleExecutionFunction(writer, func_name, module_name);
            }
        }
    }
}

/// Generate a single execution function
fn generateSingleExecutionFunction(writer: anytype, func_name: []const u8, module_name: []const u8) !void {
    try writer.print(
        \\fn execute{s}(args: []const []const u8, allocator: std.mem.Allocator, context: anytype) !void {{
        \\    const module = @import("{s}");
        \\    
        \\    // Parse options and args together (supports mixed order)
        \\    var remaining_args: []const []const u8 = args;
        \\    
        \\    var remaining_args_slice: ?[]const []const u8 = null;
        \\    const parsed_options = if (@hasDecl(module, "Options")) blk: {{
        \\        const command_meta = if (@hasDecl(module, "meta")) module.meta else null;
        \\        const parse_result = zcli.parseOptionsAndArgs(module.Options, command_meta, allocator, remaining_args);
        \\        switch (parse_result) {{
        \\            .ok => |result| {{
        \\                remaining_args_slice = result.remaining_args;
        \\                remaining_args = result.remaining_args;
        \\                break :blk result.options;
        \\            }},
        \\            .err => |err| {{
        \\                const desc = err.description(context.allocator) catch "Unknown error";
        \\                defer context.allocator.free(desc);
        \\                try context.io.stderr.print("Error parsing options: {{s}}\\n", .{{desc}});
        \\                return;
        \\            }},
        \\        }}
        \\    }} else undefined;
        \\    defer if (@hasDecl(module, "Options")) {{
        \\        cleanupArrayOptions(module.Options, parsed_options, allocator);
        \\    }};
        \\    defer if (remaining_args_slice) |slice| {{
        \\        allocator.free(slice);
        \\    }};
        \\    
        \\    // Parse remaining arguments
        \\    const parsed_args = if (@hasDecl(module, "Args")) blk: {{
        \\        const result = zcli.parseArgs(module.Args, remaining_args);
        \\        switch (result) {{
        \\            .ok => |parsed| break :blk parsed,
        \\            .err => |err| {{
        \\                const desc = err.description(context.allocator) catch "Unknown error";
        \\                defer context.allocator.free(desc);
        \\                try context.io.stderr.print("Error parsing arguments: {{s}}\\n", .{{desc}});
        \\                return;
        \\            }},
        \\        }}
        \\    }} else undefined;
        \\    
        \\    // Execute command  
        \\    if (@hasDecl(module, "execute")) {{
        \\        // Create a zcli.Context for backward compatibility
        \\        var compat_context = zcli.Context{{
        \\            .allocator = context.allocator,
        \\            .io = context.io,
        \\            .environment = context.env,
        \\        }};
        \\        
        \\        if (@hasDecl(module, "Args") and @hasDecl(module, "Options")) {{
        \\            try module.execute(parsed_args, parsed_options, &compat_context);
        \\        }} else if (@hasDecl(module, "Args")) {{
        \\            try module.execute(parsed_args, &compat_context);
        \\        }} else if (@hasDecl(module, "Options")) {{
        \\            try module.execute(parsed_options, &compat_context);
        \\        }} else {{
        \\            try module.execute(&compat_context);
        \\        }}
        \\    }} else {{
        \\        try context.io.stderr.print("Command does not implement execute function\\n", .{{}});
        \\    }}
        \\}}
        \\
        \\
    , .{ func_name, module_name });
}

/// Generate registry commands structure
fn generateRegistryCommands(writer: anytype, commands: DiscoveredCommands) !void {
    var it = commands.root.iterator();
    while (it.next()) |entry| {
        const cmd_name = entry.key_ptr.*;
        const cmd_info = entry.value_ptr.*;
        
        if (cmd_info.is_group) {
            try generateGroupRegistry(writer, cmd_name, &cmd_info, commands.allocator);
        } else {
            const func_name = if (std.mem.eql(u8, cmd_name, "test")) 
                "executetest" 
            else 
                try std.fmt.allocPrint(commands.allocator, "execute{s}", .{cmd_name});
            defer if (!std.mem.eql(u8, cmd_name, "test")) commands.allocator.free(func_name);
            
            if (std.mem.eql(u8, cmd_name, "test")) {
                try writer.print("        .@\"{s}\" = .{{ .execute = {s} }},\n", .{ cmd_name, func_name });
            } else {
                try writer.print("        .{s} = .{{ .execute = {s} }},\n", .{ cmd_name, func_name });
            }
        }
    }
}

/// Generate registry for command groups
fn generateGroupRegistry(writer: anytype, group_name: []const u8, group_info: *const CommandInfo, allocator: std.mem.Allocator) !void {
    try writer.print("        .{s} = .{{\n", .{group_name});
    try writer.writeAll("            ._is_group = true,\n");
    
    if (group_info.subcommands) |subcommands| {
        var it = subcommands.iterator();
        while (it.next()) |entry| {
            const subcmd_name = entry.key_ptr.*;
            const subcmd_info = entry.value_ptr.*;
            
            if (subcmd_info.is_group) {
                try generateGroupRegistry(writer, subcmd_name, &subcmd_info, allocator);
            } else {
                const func_name = try std.fmt.allocPrint(allocator, "execute{s}{s}", .{ group_name, subcmd_name });
                defer allocator.free(func_name);
                
                // Special case: index.zig becomes _index for group default handler
                if (std.mem.eql(u8, subcmd_name, "index")) {
                    try writer.print("            ._index = .{{ .execute = {s} }},\n", .{func_name});
                } else {
                    try writer.print("            .{s} = .{{ .execute = {s} }},\n", .{ subcmd_name, func_name });
                }
            }
        }
    }
    
    try writer.writeAll("        },\n");
}