const std = @import("std");
const types = @import("types.zig");

const PluginInfo = types.PluginInfo;
const DiscoveredCommands = types.DiscoveredCommands;
const CommandInfo = types.CommandInfo;
const BuildConfig = types.BuildConfig;

// ============================================================================
// SIMPLE CODE GENERATION - Minimal registry source generation with comptime
// ============================================================================

/// Generate comptime registry source code
pub fn generateComptimeRegistrySource(
    allocator: std.mem.Allocator,
    commands: DiscoveredCommands,
    config: BuildConfig,
    plugins: []const PluginInfo,
) ![]u8 {
    var source = std.ArrayList(u8).init(allocator);
    defer source.deinit();

    const writer = source.writer();

    // Generate header
    try writer.writeAll("// Generated by zcli - DO NOT EDIT\n\n");
    try writer.writeAll("const std = @import(\"std\");\n");
    try writer.writeAll("const zcli = @import(\"zcli\");\n\n");

    // Generate command imports
    try generateCommandImports(writer, commands);

    // Generate plugin imports
    try generatePluginImports(writer, plugins, allocator);

    // Generate the simple registry
    try generateSimpleRegistry(writer, commands, config, plugins, allocator);

    return source.toOwnedSlice();
}

/// Generate command module imports
fn generateCommandImports(writer: anytype, commands: DiscoveredCommands) !void {
    var it = commands.root.iterator();
    while (it.next()) |entry| {
        const cmd_name = entry.key_ptr.*;
        const cmd_info = entry.value_ptr.*;

        if (cmd_info.is_group) {
            try generateGroupImports(writer, cmd_name, &cmd_info);
        } else {
            const module_name = if (std.mem.eql(u8, cmd_name, "test"))
                "cmd_test"
            else
                try std.fmt.allocPrint(commands.allocator, "cmd_{s}", .{cmd_name});
            defer if (!std.mem.eql(u8, cmd_name, "test")) commands.allocator.free(module_name);

            try writer.print("const {s} = @import(\"{s}\");\n", .{ module_name, module_name });
        }
    }
    try writer.writeAll("\n");
}

/// Generate group command imports recursively
fn generateGroupImports(writer: anytype, group_name: []const u8, group_info: *const CommandInfo) !void {
    if (group_info.subcommands) |subcommands| {
        var it = subcommands.iterator();
        while (it.next()) |entry| {
            const subcmd_name = entry.key_ptr.*;
            const subcmd_info = entry.value_ptr.*;

            if (subcmd_info.is_group) {
                try generateGroupImports(writer, subcmd_name, &subcmd_info);
            } else {
                const module_name = try std.fmt.allocPrint(subcommands.allocator, "{s}_{s}", .{ group_name, subcmd_name });
                defer subcommands.allocator.free(module_name);

                try writer.print("const {s} = @import(\"{s}\");\n", .{ module_name, module_name });
            }
        }
    }
}

/// Generate plugin imports
fn generatePluginImports(writer: anytype, plugins: []const PluginInfo, allocator: std.mem.Allocator) !void {
    for (plugins) |plugin_info| {
        const plugin_var_name = try pluginVarName(allocator, plugin_info.name);
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print("const {s} = @import(\"{s}\");\n", .{ plugin_var_name, plugin_info.import_name });
    }
    if (plugins.len > 0) {
        try writer.writeAll("\n");
    }
}

/// Generate the simple comptime registry
fn generateSimpleRegistry(writer: anytype, commands: DiscoveredCommands, config: BuildConfig, plugins: []const PluginInfo, allocator: std.mem.Allocator) !void {
    // Generate the registry
    try writer.print(
        \\pub const registry = zcli.Registry.init(.{{
        \\    .app_name = "{s}",
        \\    .app_version = "{s}",
        \\    .app_description = "{s}",
        \\}})
    , .{ config.app_name, config.app_version, config.app_description });

    // Register commands
    try generateCommandRegistrations(writer, commands, allocator);

    // Register plugins
    try generatePluginRegistrations(writer, plugins, allocator);

    // Build the final registry
    try writer.writeAll("\n    .build();\n\n");

    // Export app config constants and initialization function
    try writer.print(
        \\pub const Context = @TypeOf(registry).Context;
        \\pub const app_name = "{s}";
        \\pub const app_version = "{s}";
        \\pub const app_description = "{s}";
        \\
        \\pub fn init(allocator: std.mem.Allocator) @TypeOf(registry) {{
        \\    _ = allocator;
        \\    return registry;
        \\}}
        \\
    , .{ config.app_name, config.app_version, config.app_description });
}

/// Generate command registrations
fn generateCommandRegistrations(writer: anytype, commands: DiscoveredCommands, allocator: std.mem.Allocator) !void {
    var it = commands.root.iterator();
    while (it.next()) |entry| {
        const cmd_name = entry.key_ptr.*;
        const cmd_info = entry.value_ptr.*;

        if (cmd_info.is_group) {
            try generateGroupRegistrations(writer, cmd_name, &cmd_info, allocator);
        } else {
            const module_name = if (std.mem.eql(u8, cmd_name, "test"))
                "cmd_test"
            else
                try std.fmt.allocPrint(allocator, "cmd_{s}", .{cmd_name});
            defer if (!std.mem.eql(u8, cmd_name, "test")) allocator.free(module_name);

            try writer.print("\n    .register(\"{s}\", {s})", .{ cmd_name, module_name });
        }
    }
}

/// Generate group command registrations recursively
fn generateGroupRegistrations(writer: anytype, group_name: []const u8, group_info: *const CommandInfo, allocator: std.mem.Allocator) !void {
    if (group_info.subcommands) |subcommands| {
        var it = subcommands.iterator();
        while (it.next()) |entry| {
            const subcmd_name = entry.key_ptr.*;
            const subcmd_info = entry.value_ptr.*;

            if (subcmd_info.is_group) {
                try generateGroupRegistrations(writer, subcmd_name, &subcmd_info, allocator);
            } else {
                const module_name = try std.fmt.allocPrint(allocator, "{s}_{s}", .{ group_name, subcmd_name });
                defer allocator.free(module_name);

                const command_path = if (std.mem.eql(u8, subcmd_name, "index"))
                    try std.fmt.allocPrint(allocator, "{s}", .{group_name})
                else
                    try std.fmt.allocPrint(allocator, "{s} {s}", .{ group_name, subcmd_name });
                defer allocator.free(command_path);

                try writer.print("\n    .register(\"{s}\", {s})", .{ command_path, module_name });
            }
        }
    }
}

/// Generate plugin registrations
fn generatePluginRegistrations(writer: anytype, plugins: []const PluginInfo, allocator: std.mem.Allocator) !void {
    for (plugins) |plugin_info| {
        const plugin_var_name = try pluginVarName(allocator, plugin_info.name);
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print("\n    .registerPlugin({s})", .{plugin_var_name});
    }
}

/// Convert plugin name to valid Zig variable name (replace hyphens with underscores)
fn pluginVarName(allocator: std.mem.Allocator, plugin_name: []const u8) ![]const u8 {
    return std.mem.replaceOwned(u8, allocator, plugin_name, "-", "_") catch plugin_name;
}

/// Legacy function for backward compatibility - generates registry source without plugins
/// This is a wrapper around generateComptimeRegistrySource for tests that expect the old interface
pub fn generateRegistrySource(allocator: std.mem.Allocator, commands: DiscoveredCommands, options: anytype) ![]u8 {
    // Convert options to BuildConfig
    const config = BuildConfig{
        .commands_dir = "", // Not used in code generation
        .plugins_dir = null,
        .plugins = null,
        .app_name = options.app_name,
        .app_version = options.app_version,
        .app_description = options.app_description,
    };

    // Call the new function with no plugins
    return generateComptimeRegistrySource(allocator, commands, config, &.{});
}
