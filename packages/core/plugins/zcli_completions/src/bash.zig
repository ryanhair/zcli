const std = @import("std");
const zcli = @import("zcli");

/// Generate bash completion script for the given app
pub fn generate(
    allocator: std.mem.Allocator,
    app_name: []const u8,
    commands: []const zcli.CommandInfo,
    global_options: []const zcli.OptionInfo,
) ![]const u8 {
    var buf = std.ArrayList(u8){};
    errdefer buf.deinit(allocator);
    const writer = buf.writer(allocator);

    // Header comment
    try writer.print("# bash completion for {s}\n", .{app_name});
    try writer.writeAll("# Generated by zcli-completions plugin\n\n");

    // Main completion function
    try writer.print("_{s}_completions() {{\n", .{app_name});
    try writer.writeAll("    local cur prev words cword\n");
    try writer.writeAll("    _init_completion || return\n\n");

    // Get the command path (everything between app name and current word)
    try writer.writeAll("    # Build command path from words\n");
    try writer.writeAll("    local cmd_path=()\n");
    try writer.writeAll("    local i\n");
    try writer.writeAll("    for ((i=1; i<cword; i++)); do\n");
    try writer.writeAll("        local word=\"${words[i]}\"\n");
    try writer.writeAll("        # Skip options\n");
    try writer.writeAll("        if [[ \"$word\" != -* ]]; then\n");
    try writer.writeAll("            cmd_path+=(\"$word\")\n");
    try writer.writeAll("        fi\n");
    try writer.writeAll("    done\n\n");

    // Handle option completion
    try writer.writeAll("    # If current word starts with -, complete options\n");
    try writer.writeAll("    if [[ \"$cur\" == -* ]]; then\n");
    try writer.writeAll("        local opts=\"");

    // Add global options
    for (global_options) |opt| {
        try writer.print("--{s} ", .{opt.name});
        if (opt.short) |short| {
            try writer.print("-{c} ", .{short});
        }
    }

    try writer.writeAll("\"\n");
    try writer.writeAll("        COMPREPLY=($(compgen -W \"$opts\" -- \"$cur\"))\n");
    try writer.writeAll("        return 0\n");
    try writer.writeAll("    fi\n\n");

    // Command completion based on current path
    try writer.writeAll("    # Complete commands based on current path\n");
    try writer.writeAll("    local path_len=${#cmd_path[@]}\n");
    try writer.writeAll("    local completions=()\n\n");

    // Generate completion logic for each command depth
    try writer.writeAll("    case \"$path_len\" in\n");

    // Build a map of depth -> commands at that depth
    var depth_map = std.AutoHashMap(usize, std.ArrayList([]const u8)).init(allocator);
    defer {
        var it = depth_map.valueIterator();
        while (it.next()) |list| {
            list.deinit(allocator);
        }
        depth_map.deinit();
    }

    for (commands) |cmd| {
        const depth = cmd.path.len;
        const entry = try depth_map.getOrPut(depth);
        if (!entry.found_existing) {
            entry.value_ptr.* = std.ArrayList([]const u8){};
        }

        // Get the command name at this level
        const cmd_name = cmd.path[depth - 1];
        try entry.value_ptr.append(allocator, cmd_name);
    }

    // Sort depths for consistent output
    var depths = std.ArrayList(usize){};
    defer depths.deinit(allocator);
    var depth_it = depth_map.keyIterator();
    while (depth_it.next()) |depth| {
        try depths.append(allocator, depth.*);
    }
    std.mem.sort(usize, depths.items, {}, std.sort.asc(usize));

    // Generate cases for each depth
    for (depths.items) |depth| {
        try writer.print("        {d})\n", .{depth});

        const cmds = depth_map.get(depth).?;

        // Need to check the path matches
        if (depth == 1) {
            // Root level - just list commands
            try writer.writeAll("            completions=(");
            for (cmds.items) |cmd_name| {
                try writer.print("\"{s}\" ", .{cmd_name});
            }
            try writer.writeAll(")\n");
        } else {
            // Need to check parent path matches
            try writer.writeAll("            case \"${cmd_path[@]}\" in\n");

            // Group commands by parent path
            var parent_map = std.StringHashMap(std.ArrayList([]const u8)).init(allocator);
            defer {
                var it = parent_map.valueIterator();
                while (it.next()) |list| {
                    list.deinit(allocator);
                }
                parent_map.deinit();
            }

            for (commands) |cmd| {
                if (cmd.path.len != depth) continue;

                // Build parent path string
                var parent_path = std.ArrayList(u8){};
                defer parent_path.deinit(allocator);
                for (cmd.path[0 .. depth - 1], 0..) |part, idx| {
                    if (idx > 0) try parent_path.append(allocator, ' ');
                    try parent_path.appendSlice(allocator, part);
                }

                const parent_key = try allocator.dupe(u8, parent_path.items);
                const entry = try parent_map.getOrPut(parent_key);
                if (!entry.found_existing) {
                    entry.value_ptr.* = std.ArrayList([]const u8){};
                } else {
                    allocator.free(parent_key);
                }

                const cmd_name = cmd.path[depth - 1];
                try entry.value_ptr.append(allocator, cmd_name);
            }

            // Generate case for each parent path
            var parent_it = parent_map.iterator();
            while (parent_it.next()) |entry| {
                try writer.print("                \"{s}\")\n", .{entry.key_ptr.*});
                try writer.writeAll("                    completions=(");
                for (entry.value_ptr.items) |cmd_name| {
                    try writer.print("\"{s}\" ", .{cmd_name});
                }
                try writer.writeAll(")\n");
                try writer.writeAll("                    ;;\n");
            }

            try writer.writeAll("            esac\n");
        }

        try writer.writeAll("            ;;\n");
    }

    try writer.writeAll("    esac\n\n");

    // Generate completions
    try writer.writeAll("    COMPREPLY=($(compgen -W \"${completions[*]}\" -- \"$cur\"))\n");
    try writer.writeAll("    return 0\n");
    try writer.writeAll("}\n\n");

    // Register completion
    try writer.print("complete -F _{s}_completions {s}\n", .{ app_name, app_name });

    return buf.toOwnedSlice(allocator);
}
