const std = @import("std");
const zcli = @import("zcli");

/// Generate fish completion script for the given app
pub fn generate(
    allocator: std.mem.Allocator,
    app_name: []const u8,
    commands: []const zcli.CommandInfo,
    global_options: []const zcli.OptionInfo,
) ![]const u8 {
    var buf = std.ArrayList(u8){};
    errdefer buf.deinit(allocator);
    const writer = buf.writer(allocator);

    // Header
    try writer.print("# fish completion for {s}\n", .{app_name});
    try writer.writeAll("# Generated by zcli-completions plugin\n\n");

    // Global options (available for all commands)
    for (global_options) |opt| {
        try writer.print("complete -c {s}", .{app_name});

        if (opt.short) |short| {
            try writer.print(" -s {c}", .{short});
        }
        try writer.print(" -l {s}", .{opt.name});

        if (opt.description) |desc| {
            try writer.print(" -d '{s}'", .{desc});
        }

        if (opt.takes_value) {
            try writer.print(" -r", .{});
        }

        try writer.writeAll("\n");
    }

    if (global_options.len > 0) {
        try writer.writeAll("\n");
    }

    // Build command tree to understand nesting
    var command_tree = std.StringHashMap(std.ArrayList([]const u8)).init(allocator);
    defer {
        var it = command_tree.valueIterator();
        while (it.next()) |list| {
            list.deinit(allocator);
        }
        command_tree.deinit();
    }

    // Track which paths are "parents" (have subcommands)
    var parent_paths = std.StringHashMap(void).init(allocator);
    defer parent_paths.deinit();

    for (commands) |cmd| {
        if (cmd.path.len == 1) {
            // Root level command
            const entry = try command_tree.getOrPut("");
            if (!entry.found_existing) {
                entry.value_ptr.* = std.ArrayList([]const u8){};
            }
            try entry.value_ptr.append(allocator, cmd.path[0]);
        } else {
            // Nested command - mark parents
            for (0..cmd.path.len - 1) |i| {
                var parent_path = std.ArrayList(u8){};
                defer parent_path.deinit(allocator);
                for (cmd.path[0 .. i + 1], 0..) |part, idx| {
                    if (idx > 0) try parent_path.append(allocator, ' ');
                    try parent_path.appendSlice(allocator, part);
                }
                const parent_key = try allocator.dupe(u8, parent_path.items);
                try parent_paths.put(parent_key, {});
            }

            // Add to command tree
            var parent_path = std.ArrayList(u8){};
            defer parent_path.deinit(allocator);
            for (cmd.path[0 .. cmd.path.len - 1], 0..) |part, idx| {
                if (idx > 0) try parent_path.append(allocator, ' ');
                try parent_path.appendSlice(allocator, part);
            }

            const parent_key = try allocator.dupe(u8, parent_path.items);
            const entry = try command_tree.getOrPut(parent_key);
            if (!entry.found_existing) {
                entry.value_ptr.* = std.ArrayList([]const u8){};
            } else {
                allocator.free(parent_key);
            }
            try entry.value_ptr.append(allocator, cmd.path[cmd.path.len - 1]);
        }
    }

    // Root level commands (no condition)
    if (command_tree.get("")) |root_cmds| {
        for (root_cmds.items) |cmd_name| {
            // Find description
            var desc: ?[]const u8 = null;
            for (commands) |cmd| {
                if (cmd.path.len == 1 and std.mem.eql(u8, cmd.path[0], cmd_name)) {
                    desc = cmd.description;
                    break;
                }
            }

            try writer.print("complete -c {s} -f -n \"__fish_use_subcommand\" -a {s}", .{ app_name, cmd_name });
            if (desc) |d| {
                try writer.print(" -d '{s}'", .{d});
            }
            try writer.writeAll("\n");
        }
    }

    try writer.writeAll("\n");

    // Nested commands (with conditions)
    var tree_it = command_tree.iterator();
    while (tree_it.next()) |entry| {
        if (entry.key_ptr.len == 0) continue; // Skip root

        const parent_path = entry.key_ptr.*;
        const subcommands = entry.value_ptr.*;

        // Build condition: __fish_seen_subcommand_from parent1 parent2 ...
        var condition = std.ArrayList(u8){};
        defer condition.deinit(allocator);
        try condition.appendSlice(allocator, "__fish_seen_subcommand_from");

        var path_parts = std.mem.splitScalar(u8, parent_path, ' ');
        while (path_parts.next()) |part| {
            try condition.append(allocator, ' ');
            try condition.appendSlice(allocator, part);
        }

        // Only show these subcommands if not already at a deeper level
        // Check that we haven't seen any of the subcommands yet
        var has_deeper = false;
        for (subcommands.items) |subcmd_name| {
            var full_path = std.ArrayList(u8){};
            defer full_path.deinit(allocator);
            try full_path.appendSlice(allocator, parent_path);
            try full_path.append(allocator, ' ');
            try full_path.appendSlice(allocator, subcmd_name);
            if (parent_paths.contains(full_path.items)) {
                has_deeper = true;
                break;
            }
        }

        for (subcommands.items) |subcmd_name| {
            // Find description
            var desc: ?[]const u8 = null;
            for (commands) |cmd| {
                // Check if path matches
                var matches = true;
                var path_check = std.mem.splitScalar(u8, parent_path, ' ');
                var depth: usize = 0;
                while (path_check.next()) |part| {
                    if (depth >= cmd.path.len or !std.mem.eql(u8, cmd.path[depth], part)) {
                        matches = false;
                        break;
                    }
                    depth += 1;
                }
                if (matches and depth < cmd.path.len and std.mem.eql(u8, cmd.path[depth], subcmd_name)) {
                    desc = cmd.description;
                    break;
                }
            }

            try writer.print("complete -c {s} -f -n \"{s}\"", .{ app_name, condition.items });

            // If this subcommand itself has subcommands, add condition to not show it after it's been used
            var full_subcmd_path = std.ArrayList(u8){};
            defer full_subcmd_path.deinit(allocator);
            try full_subcmd_path.appendSlice(allocator, parent_path);
            try full_subcmd_path.append(allocator, ' ');
            try full_subcmd_path.appendSlice(allocator, subcmd_name);

            if (parent_paths.contains(full_subcmd_path.items)) {
                try writer.print("; and not __fish_seen_subcommand_from {s}", .{subcmd_name});
            }

            try writer.print(" -a {s}", .{subcmd_name});
            if (desc) |d| {
                try writer.print(" -d '{s}'", .{d});
            }
            try writer.writeAll("\n");
        }

        try writer.writeAll("\n");
    }

    // Add command-specific options if we have them
    // For now, we'll just add global options since extracting per-command options
    // would require more complex introspection
    // TODO: Add per-command option completions

    return buf.toOwnedSlice(allocator);
}
