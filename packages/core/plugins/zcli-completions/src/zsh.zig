const std = @import("std");
const zcli = @import("zcli");

/// Generate zsh completion script for the given app
pub fn generate(
    allocator: std.mem.Allocator,
    app_name: []const u8,
    commands: []const zcli.CommandInfo,
    global_options: []const zcli.OptionInfo,
) ![]const u8 {
    var buf = std.ArrayList(u8).init(allocator);
    errdefer buf.deinit();
    const writer = buf.writer();

    // Header
    try writer.print("#compdef {s}\n", .{app_name});
    try writer.writeAll("# zsh completion for ");
    try writer.print("{s}\n", .{app_name});
    try writer.writeAll("# Generated by zcli-completions plugin\n\n");

    // Main completion function
    try writer.print("_{s}() {{\n", .{app_name});
    try writer.writeAll("    local line state\n\n");

    // Build command tree structure
    var command_tree = std.StringHashMap(std.ArrayList([]const u8)).init(allocator);
    defer {
        var it = command_tree.valueIterator();
        while (it.next()) |list| {
            list.deinit();
        }
        command_tree.deinit();
    }

    // Build tree of commands (parent -> children)
    for (commands) |cmd| {
        if (cmd.path.len == 1) {
            // Root level command
            const entry = try command_tree.getOrPut("");
            if (!entry.found_existing) {
                entry.value_ptr.* = std.ArrayList([]const u8).init(allocator);
            }
            try entry.value_ptr.append(cmd.path[0]);
        } else {
            // Nested command - build parent path
            var parent_path = std.ArrayList(u8).init(allocator);
            defer parent_path.deinit();
            for (cmd.path[0 .. cmd.path.len - 1], 0..) |part, idx| {
                if (idx > 0) try parent_path.append(' ');
                try parent_path.appendSlice(part);
            }

            const parent_key = try allocator.dupe(u8, parent_path.items);
            const entry = try command_tree.getOrPut(parent_key);
            if (!entry.found_existing) {
                entry.value_ptr.* = std.ArrayList([]const u8).init(allocator);
            } else {
                allocator.free(parent_key);
            }
            try entry.value_ptr.append(cmd.path[cmd.path.len - 1]);
        }
    }

    // Generate _arguments call with global options
    try writer.writeAll("    _arguments -C \\\n");

    // Add global options
    for (global_options) |opt| {
        if (opt.short) |short| {
            try writer.print("        '(-{c} --{s})", .{ short, opt.name });
            try writer.print("{{-{c},--{s}}}", .{ short, opt.name });
        } else {
            try writer.print("        '--{s}", .{opt.name});
        }

        if (opt.description) |desc| {
            try writer.print("[{s}]", .{desc});
        }

        if (opt.takes_value) {
            try writer.print(":{s}:'", .{opt.name});
        } else {
            try writer.print("'", .{});
        }
        try writer.writeAll(" \\\n");
    }

    // Add subcommand argument
    try writer.writeAll("        '1: :->command' \\\n");
    try writer.writeAll("        '*::arg:->args'\n\n");

    // Handle command state
    try writer.writeAll("    case $state in\n");
    try writer.writeAll("        command)\n");
    try writer.writeAll("            local -a commands\n");
    try writer.writeAll("            commands=(\n");

    // List root-level commands
    if (command_tree.get("")) |root_cmds| {
        for (root_cmds.items) |cmd_name| {
            // Find description for this command
            var desc: ?[]const u8 = null;
            for (commands) |cmd| {
                if (cmd.path.len == 1 and std.mem.eql(u8, cmd.path[0], cmd_name)) {
                    desc = cmd.description;
                    break;
                }
            }

            try writer.print("                '{s}", .{cmd_name});
            if (desc) |d| {
                try writer.print(":{s}", .{d});
            }
            try writer.writeAll("'\n");
        }
    }

    try writer.writeAll("            )\n");
    try writer.writeAll("            _describe 'command' commands\n");
    try writer.writeAll("            ;;\n");

    // Handle args state - subcommands
    try writer.writeAll("        args)\n");
    try writer.writeAll("            case $line[1] in\n");

    // Generate cases for each command that has subcommands
    var tree_it = command_tree.iterator();
    while (tree_it.next()) |entry| {
        if (entry.key_ptr.len == 0) continue; // Skip root

        // Convert path to case pattern (space-separated)
        const parent_path = entry.key_ptr.*;
        const subcommands = entry.value_ptr.*;

        // For nested paths, we need to check multiple levels
        // For now, let's handle one level of nesting
        var path_parts = std.mem.splitScalar(u8, parent_path, ' ');
        const first_part = path_parts.next().?;

        try writer.print("                {s})\n", .{first_part});

        // Check if we need to go deeper
        const rest = path_parts.rest();
        if (rest.len > 0) {
            // Multi-level nesting
            try writer.print("                    case $line[2] in\n", .{});
            try writer.print("                        {s})\n", .{rest});
        }

        try writer.writeAll("                            local -a subcommands\n");
        try writer.writeAll("                            subcommands=(\n");

        for (subcommands.items) |subcmd_name| {
            // Find description
            var desc: ?[]const u8 = null;
            for (commands) |cmd| {
                if (cmd.path.len < 2) continue;
                // Check if path matches
                var matches = true;
                var path_check = std.mem.splitScalar(u8, parent_path, ' ');
                var depth: usize = 0;
                while (path_check.next()) |part| {
                    if (depth >= cmd.path.len or !std.mem.eql(u8, cmd.path[depth], part)) {
                        matches = false;
                        break;
                    }
                    depth += 1;
                }
                if (matches and depth < cmd.path.len and std.mem.eql(u8, cmd.path[depth], subcmd_name)) {
                    desc = cmd.description;
                    break;
                }
            }

            try writer.print("                                '{s}", .{subcmd_name});
            if (desc) |d| {
                try writer.print(":{s}", .{d});
            }
            try writer.writeAll("'\n");
        }

        try writer.writeAll("                            )\n");
        try writer.writeAll("                            _describe 'subcommand' subcommands\n");

        if (rest.len > 0) {
            try writer.writeAll("                            ;;\n");
            try writer.writeAll("                    esac\n");
        }

        try writer.writeAll("                    ;;\n");
    }

    try writer.writeAll("            esac\n");
    try writer.writeAll("            ;;\n");
    try writer.writeAll("    esac\n");

    try writer.writeAll("}\n\n");

    // Call the function
    try writer.print("_{s} \"$@\"\n", .{app_name});

    return buf.toOwnedSlice();
}
