const std = @import("std");
const types = @import("types.zig");

const PluginInfo = types.PluginInfo;
const DiscoveredCommands = types.DiscoveredCommands;
const CommandInfo = types.CommandInfo;
const CommandType = types.CommandType;
const BuildConfig = types.BuildConfig;

// ============================================================================
// SIMPLE CODE GENERATION - Minimal registry source generation with comptime
// ============================================================================

/// Generate comptime registry source code
pub fn generateComptimeRegistrySource(
    allocator: std.mem.Allocator,
    commands: DiscoveredCommands,
    config: BuildConfig,
    plugins: []const PluginInfo,
) ![]u8 {
    var source = std.ArrayList(u8).init(allocator);
    defer source.deinit();

    const writer = source.writer();

    // Generate header
    try writer.writeAll("// Generated by zcli - DO NOT EDIT\n\n");
    try writer.writeAll("const std = @import(\"std\");\n");
    try writer.writeAll("const zcli = @import(\"zcli\");\n\n");

    // Generate command imports
    try generateCommandImports(writer, commands);

    // Generate plugin imports
    try generatePluginImports(writer, plugins, allocator);

    // Generate the simple registry
    try generateSimpleRegistry(writer, commands, config, plugins, allocator);

    // Generate pure command groups metadata
    try generatePureCommandGroups(writer, commands, allocator);

    return source.toOwnedSlice();
}

/// Generate command module imports
fn generateCommandImports(writer: anytype, commands: DiscoveredCommands) !void {
    var it = commands.root.iterator();
    while (it.next()) |entry| {
        const cmd_name = entry.key_ptr.*;
        const cmd_info = entry.value_ptr.*;

        if (cmd_info.command_type != .leaf) {
            // Generate import for optional group with index file
            if (cmd_info.command_type == .optional_group) {
                const module_name = try std.fmt.allocPrint(commands.allocator, "{s}_index", .{cmd_name});
                defer commands.allocator.free(module_name);

                try writer.print("const {s} = @import(\"{s}\");\n", .{ module_name, module_name });
            }
            // Generate imports for subcommands
            try generateGroupImports(writer, cmd_name, &cmd_info);
        } else {
            const module_name = if (std.mem.eql(u8, cmd_name, "test"))
                "cmd_test"
            else
                try std.fmt.allocPrint(commands.allocator, "cmd_{s}", .{cmd_name});
            defer if (!std.mem.eql(u8, cmd_name, "test")) commands.allocator.free(module_name);

            try writer.print("const {s} = @import(\"{s}\");\n", .{ module_name, module_name });
        }
    }
    try writer.writeAll("\n");
}

/// Generate group command imports recursively
fn generateGroupImports(writer: anytype, _: []const u8, group_info: *const CommandInfo) !void {
    if (group_info.subcommands) |subcommands| {
        var it = subcommands.iterator();
        while (it.next()) |entry| {
            const subcmd_name = entry.key_ptr.*;
            const subcmd_info = entry.value_ptr.*;

            if (subcmd_info.command_type == .optional_group) {
                // Generate import for optional group with index file
                var module_name_parts = std.ArrayList([]const u8).init(subcommands.allocator);
                defer module_name_parts.deinit();

                for (subcmd_info.path) |part| {
                    const sanitized_part = try sanitizeIdentifier(subcommands.allocator, part);
                    defer if (sanitized_part.ptr != part.ptr) subcommands.allocator.free(sanitized_part);
                    try module_name_parts.append(try subcommands.allocator.dupe(u8, sanitized_part));
                }

                const module_name = try std.mem.join(subcommands.allocator, "_", module_name_parts.items);
                defer {
                    for (module_name_parts.items) |part| {
                        subcommands.allocator.free(part);
                    }
                    subcommands.allocator.free(module_name);
                }

                const module_name_with_index = try std.fmt.allocPrint(subcommands.allocator, "{s}_index", .{module_name});
                defer subcommands.allocator.free(module_name_with_index);

                try writer.print("const {s} = @import(\"{s}\");\n", .{ module_name_with_index, module_name_with_index });

                // Also recurse for subcommands
                try generateGroupImports(writer, subcmd_name, &subcmd_info);
            } else if (subcmd_info.command_type == .pure_group) {
                // Pure groups have no imports, just recurse
                try generateGroupImports(writer, subcmd_name, &subcmd_info);
            } else {
                // Generate module name from full command path to match module_creation.zig
                var module_name_parts = std.ArrayList([]const u8).init(subcommands.allocator);
                defer module_name_parts.deinit();

                for (subcmd_info.path) |part| {
                    const sanitized_part = try sanitizeIdentifier(subcommands.allocator, part);
                    defer if (sanitized_part.ptr != part.ptr) subcommands.allocator.free(sanitized_part);
                    try module_name_parts.append(try subcommands.allocator.dupe(u8, sanitized_part));
                }

                const module_name = try std.mem.join(subcommands.allocator, "_", module_name_parts.items);
                defer {
                    for (module_name_parts.items) |part| {
                        subcommands.allocator.free(part);
                    }
                    subcommands.allocator.free(module_name);
                }

                try writer.print("const {s} = @import(\"{s}\");\n", .{ module_name, module_name });
            }
        }
    }
}

/// Generate plugin imports and initialization
fn generatePluginImports(writer: anytype, plugins: []const PluginInfo, allocator: std.mem.Allocator) !void {
    for (plugins) |plugin_info| {
        const plugin_var_name = try pluginVarName(allocator, plugin_info.name);
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        if (plugin_info.init) |init_code| {
            // Plugin has initialization code - call it on import
            try writer.print("const {s} = @import(\"{s}\"){s};\n", .{ plugin_var_name, plugin_info.import_name, init_code });
        } else {
            // Normal plugin without config - import directly
            try writer.print("const {s} = @import(\"{s}\");\n", .{ plugin_var_name, plugin_info.import_name });
        }
    }
    if (plugins.len > 0) {
        try writer.writeAll("\n");
    }
}

/// Generate the simple comptime registry
fn generateSimpleRegistry(writer: anytype, commands: DiscoveredCommands, config: BuildConfig, plugins: []const PluginInfo, allocator: std.mem.Allocator) !void {
    // Generate the registry type (private)
    try writer.print(
        \\const RegistryType = zcli.Registry.init(.{{
        \\    .app_name = "{s}",
        \\    .app_version = "{s}",
        \\    .app_description = "{s}",
        \\}})
    , .{ config.app_name, config.app_version, config.app_description });

    // Register commands
    try generateCommandRegistrations(writer, commands, allocator);

    // Register plugins
    try generatePluginRegistrations(writer, plugins, allocator);

    // Build the final registry type
    try writer.writeAll("\n    .build();\n\n");

    // Export app config constants and initialization function
    try writer.print(
        \\pub const Context = RegistryType.Context;
        \\pub const app_name = "{s}";
        \\pub const app_version = "{s}";
        \\pub const app_description = "{s}";
        \\
        \\pub fn init() RegistryType {{
        \\    return RegistryType.init();
        \\}}
        \\
    , .{ config.app_name, config.app_version, config.app_description });
}

/// Generate metadata for pure command groups
fn generatePureCommandGroups(writer: anytype, commands: DiscoveredCommands, allocator: std.mem.Allocator) !void {
    try writer.writeAll("// Pure command groups (directories without index.zig)\n");
    try writer.writeAll("pub const pure_command_groups = [_][]const []const u8{\n");

    // Recursively find and generate pure command groups
    try generatePureGroupsFromMap(writer, &commands.root, allocator);

    try writer.writeAll("};\n\n");
}

/// Recursively generate pure command group entries
fn generatePureGroupsFromMap(writer: anytype, command_map: *const std.StringHashMap(CommandInfo), allocator: std.mem.Allocator) !void {
    var it = command_map.iterator();
    while (it.next()) |entry| {
        const cmd_info = entry.value_ptr.*;

        if (cmd_info.command_type == .pure_group) {
            // Generate entry for this pure group
            try writer.writeAll("    &.{");
            for (cmd_info.path, 0..) |component, idx| {
                if (idx > 0) try writer.writeAll(", ");
                try writer.print("\"{s}\"", .{component});
            }
            try writer.writeAll("},\n");
        }

        // Recursively process subcommands
        if (cmd_info.subcommands) |subcommands| {
            try generatePureGroupsFromMap(writer, &subcommands, allocator);
        }
    }
}

/// Generate command registrations
fn generateCommandRegistrations(writer: anytype, commands: DiscoveredCommands, allocator: std.mem.Allocator) !void {
    var it = commands.root.iterator();
    while (it.next()) |entry| {
        const cmd_name = entry.key_ptr.*;
        const cmd_info = entry.value_ptr.*;

        if (cmd_info.command_type != .leaf) {
            // Register optional group with index file as a command
            if (cmd_info.command_type == .optional_group) {
                const module_name = try std.fmt.allocPrint(allocator, "{s}_index", .{cmd_name});
                defer allocator.free(module_name);

                const command_path_str = try std.mem.join(allocator, " ", cmd_info.path);
                defer allocator.free(command_path_str);

                try writer.print("\n    .register(\"{s}\", {s})", .{ command_path_str, module_name });
            }
            // Register subcommands
            try generateGroupRegistrations(writer, cmd_name, &cmd_info, allocator);
        } else {
            const module_name = if (std.mem.eql(u8, cmd_name, "test"))
                "cmd_test"
            else
                try std.fmt.allocPrint(allocator, "cmd_{s}", .{cmd_name});
            defer if (!std.mem.eql(u8, cmd_name, "test")) allocator.free(module_name);

            // Use the actual command path from CommandInfo (it's now an array)
            const command_path_str = try std.mem.join(allocator, " ", cmd_info.path);
            defer allocator.free(command_path_str);

            try writer.print("\n    .register(\"{s}\", {s})", .{ command_path_str, module_name });
        }
    }
}

/// Generate group command registrations recursively
fn generateGroupRegistrations(writer: anytype, _: []const u8, group_info: *const CommandInfo, allocator: std.mem.Allocator) !void {
    if (group_info.subcommands) |subcommands| {
        var it = subcommands.iterator();
        while (it.next()) |entry| {
            const subcmd_name = entry.key_ptr.*;
            const subcmd_info = entry.value_ptr.*;

            if (subcmd_info.command_type == .optional_group) {
                // Register the optional group itself
                var module_name_parts = std.ArrayList([]const u8).init(allocator);
                defer module_name_parts.deinit();

                for (subcmd_info.path) |part| {
                    const sanitized_part = try sanitizeIdentifier(allocator, part);
                    defer if (sanitized_part.ptr != part.ptr) allocator.free(sanitized_part);
                    try module_name_parts.append(try allocator.dupe(u8, sanitized_part));
                }

                const module_name = try std.mem.join(allocator, "_", module_name_parts.items);
                defer {
                    for (module_name_parts.items) |part| {
                        allocator.free(part);
                    }
                    allocator.free(module_name);
                }

                const module_name_with_index = try std.fmt.allocPrint(allocator, "{s}_index", .{module_name});
                defer allocator.free(module_name_with_index);

                const command_path_str = try std.mem.join(allocator, " ", subcmd_info.path);
                defer allocator.free(command_path_str);

                try writer.print("\n    .register(\"{s}\", {s})", .{ command_path_str, module_name_with_index });

                // Also recurse for its subcommands
                try generateGroupRegistrations(writer, subcmd_name, &subcmd_info, allocator);
            } else if (subcmd_info.command_type == .pure_group) {
                // Pure groups are not registered, just recurse
                try generateGroupRegistrations(writer, subcmd_name, &subcmd_info, allocator);
            } else {
                // Generate module name from full command path to match module_creation.zig
                var module_name_parts = std.ArrayList([]const u8).init(allocator);
                defer module_name_parts.deinit();

                for (subcmd_info.path) |part| {
                    const sanitized_part = try sanitizeIdentifier(allocator, part);
                    defer if (sanitized_part.ptr != part.ptr) allocator.free(sanitized_part);
                    try module_name_parts.append(try allocator.dupe(u8, sanitized_part));
                }

                const module_name = try std.mem.join(allocator, "_", module_name_parts.items);
                defer {
                    for (module_name_parts.items) |part| {
                        allocator.free(part);
                    }
                    allocator.free(module_name);
                }

                // Use the actual command path from the CommandInfo (it's now an array)
                const command_path_str = try std.mem.join(allocator, " ", subcmd_info.path);
                defer allocator.free(command_path_str);

                try writer.print("\n    .register(\"{s}\", {s})", .{ command_path_str, module_name });
            }
        }
    }
}

/// Generate plugin registrations
fn generatePluginRegistrations(writer: anytype, plugins: []const PluginInfo, allocator: std.mem.Allocator) !void {
    for (plugins) |plugin_info| {
        const plugin_var_name = try pluginVarName(allocator, plugin_info.name);
        defer if (plugin_var_name.ptr != plugin_info.name.ptr) allocator.free(plugin_var_name);

        try writer.print("\n    .registerPlugin({s})", .{plugin_var_name});
    }
}

/// Convert plugin name to valid Zig variable name (replace hyphens with underscores)
fn pluginVarName(allocator: std.mem.Allocator, plugin_name: []const u8) ![]const u8 {
    return std.mem.replaceOwned(u8, allocator, plugin_name, "-", "_") catch plugin_name;
}

/// Sanitize command name to valid Zig identifier (replace hyphens with underscores)
fn sanitizeIdentifier(allocator: std.mem.Allocator, name: []const u8) ![]const u8 {
    return std.mem.replaceOwned(u8, allocator, name, "-", "_") catch name;
}
